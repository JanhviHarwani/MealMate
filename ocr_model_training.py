# -*- coding: utf-8 -*-
"""OCR_model-training.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lfb20spcnjZHSe9tYAoyFq56gO4wMfRm

# **MealMate**
OCR of the image provided by the user of the Food items present in his refrigerator.

The model detects the item and the calories associated with it.

Using Food101 Dataset
"""

(train_data, test_data), ds_info = tfds.load(name='food101',
                                             split=['train', 'validation'],
                                             shuffle_files=False,
                                             as_supervised=True,
                                             with_info=True)

ds_info.features

class_names = ds_info.features['label'].names
class_names[:10]

train_one_sample = train_data.take(1)

train_one_sample

for image, label in train_one_sample:
  print(f"""
  Image Shape : {image.shape}
  Image Datatype : {image.dtype}
  Class : {class_names[label.numpy()]}
  """)

image[:2]

tf.reduce_min(image), tf.reduce_max(image)

plt.imshow(image)
plt.title(class_names[label.numpy()])
plt.axis(False);

def preprocess_img(image, label, img_size=224):
  image = tf.image.resize(image, [img_size, img_size])
  image = tf.cast(image, tf.float16)
  return image, label

# Trying the preprocess function on a single image

preprocessed_img = preprocess_img(image, label)[0]
preprocessed_img

train_data = train_data.map(preprocess_img, tf.data.AUTOTUNE)
train_data = train_data.shuffle(buffer_size=1000).batch(32).prefetch(tf.data.AUTOTUNE)

test_data = test_data.map(preprocess_img, tf.data.AUTOTUNE)
test_data = test_data.batch(32)

train_data

test_data

from helper_function import create_tensorboard_callback

# EarlyStopping Callback

early_stopping_callback = tf.keras.callbacks.EarlyStopping(restore_best_weights=True, patience=3, verbose=1, monitor="val_accuracy")

# ReduceLROnPlateau Callback

lower_lr = tf.keras.callbacks.ReduceLROnPlateau(factor=0.2,
                                                monitor='val_accuracy',
                                                min_lr=1e-7,
                                                patience=0,
                                                verbose=1)

from tensorflow.keras import mixed_precision
mixed_precision.set_global_policy(policy='mixed_float16')

mixed_precision.global_policy()

"""

### **Building the Model**"""

from tensorflow.keras import layers
from tensorflow.keras.layers.experimental import preprocessing

# Create base model
input_shape = (224, 224, 3)
base_model = tf.keras.applications.EfficientNetB1(include_top=False)

# Input and Data Augmentation
inputs = layers.Input(shape=input_shape, name="input_layer")
x = base_model(inputs)

x = layers.GlobalAveragePooling2D(name="pooling_layer")(x)
x = layers.Dropout(.3)(x)

x = layers.Dense(len(class_names))(x)
outputs = layers.Activation("softmax")(x)
model = tf.keras.Model(inputs, outputs)

# Compiling the model
model.compile(loss="sparse_categorical_crossentropy",
              optimizer=tf.keras.optimizers.Adam(0.001),
              metrics=["accuracy"])

model.summary()

history = model.fit(train_data,
                    epochs=1,
                    steps_per_epoch=len(train_data),
                    validation_data=test_data,
                    validation_steps=int(0.15 * len(test_data)),
                    callbacks=[create_tensorboard_callback("training-logs", "EfficientNetB1-"),
                               early_stopping_callback,
                               lower_lr])

# Saving the model
model.save("/content/drive/My Drive/FinalModel.hdf5")

# Saving the model
model.save("FoodVision.hdf5")

model.evaluate(test_data)

"""## **Evaluating our Model**"""

pred_probs = model.predict(test_data, verbose=1)
len(pred_probs), pred_probs.shape

pred_classes = pred_probs.argmax(axis=1)
pred_classes[:10], len(pred_classes), pred_classes.shape

# Getting true labels for the test_data

y_labels = []
test_images = []
for images, labels in test_data.unbatch():
  y_labels.append(labels.numpy())
y_labels[:10]

# Predicted Labels vs. True Labels
pred_classes==y_labels

"""### **Sklearn's Accuracy Score**"""

from sklearn.metrics import accuracy_score

sklearn_acc = accuracy_score(y_labels, pred_classes)
sklearn_acc

"""### **Confusion Matrix**
A confusion matrix is a table that is often used to describe the performance of a classification model (or "classifier") on a set of test data for which the true values are known
"""

cm = tf.math.confusion_matrix(y_labels, pred_classes)

plt.figure(figsize = (200, 200));
sn.heatmap(cm, annot=True,
           fmt='',
           cmap='Blues');

"""### **Model's Class-wise Accuracy Score**"""

from sklearn.metrics import classification_report
report = (classification_report(y_labels, pred_classes, output_dict=True))

# Create empty dictionary
class_f1_scores = {}
# Loop through classification report items
for k, v in report.items():
  if k == "accuracy": # stop once we get to accuracy key
    break
  else:
    # Append class names and f1-scores to new dictionary
    class_f1_scores[class_names[int(k)]] = v["f1-score"]
class_f1_scores

report_df = pd.DataFrame(class_f1_scores, index = ['f1-scores']).T

report_df = report_df.sort_values("f1-scores", ascending=True)

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(12, 25))
scores = ax.barh(range(len(report_df)), report_df["f1-scores"].values)
ax.set_yticks(range(len(report_df)))
plt.axvline(x=0.85, linestyle='--', color='r')
ax.set_yticklabels(class_names)
ax.set_xlabel("f1-score")
ax.set_title("F1-Scores for 10 Different Classes")
ax.invert_yaxis(); # reverse the order

"""### **Predicting on our own Custom images**

Once we have our model ready, its cruicial to evaluate it on our custom data : the data our model has never seen.

Training and evaluating a model on train and test data is cool, but making predictions on our own realtime images is another level.


"""

# Get custom food images filepaths
import os

custom_food_images = ["/content/Fridge.jpeg"]
custom_food_images

def pred_plot_custom(folder_path):
    import os
    import matplotlib.pyplot as plt
    import tensorflow as tf

    custom_food_images = [folder_path + img_path for img_path in os.listdir(folder_path)]
    i = 0
    fig, a = plt.subplots(len(custom_food_images), 2, figsize=(15, 5 * len(custom_food_images)))

    for img in custom_food_images:
        img = load_and_prep_image(img, scale=False)
        pred_prob = model.predict(tf.expand_dims(img, axis=0))
        pred_class = class_names[pred_prob.argmax()]
        top_5_i = (pred_prob.argsort())[0][-5:][::-1]
        values = pred_prob[0][top_5_i]
        labels = []
        for x in range(5):
            labels.append(class_names[top_5_i[x]])

        # Plotting Image
        a[i].imshow(img / 255.)
        a[i].set_title(f"Prediction: {pred_class}   Probability: {pred_prob.max():.2f}")
        a[i].axis(False)

        # Plotting Models Top 5 Predictions
        a[i].bar(labels, values, color='orange')
        a[i].set_title('Top 5 Predictions')
        i = i + 1

    plt.show()

pred_plot_custom("/content/fridge/")
